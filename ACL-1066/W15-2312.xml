<sec_map><section><chunk>Proceedings of the 14th Meeting on the Mathematics of Language (MoL 14), pages 139151, Chicago, USA, July 2526, 2015. c 2015 Association for Computational Linguistics </chunk></section><section><heading>A Concatenation Operation to Derive Autosegmental Graphs </heading><chunk>Adam Jardine and Jeffrey Heinz University of Delaware {ajardine,heinz}@udel.edu </chunk></section><section><heading>Abstract </heading><chunk>Autosegmental phonology represents words with graph structures. This paper introduces a way of reasoning about autosegmental graphs as strings of concatenated graph primitives. The main result shows that the sets of au- tosegmental graphs so generated obey two important, putatively universal, constraints in phonological theory provided that the graph primitives also obey these constraints. These constraints are the Obligatory Contour Prin- ciple and the No Crossing Constraint. Thus, these constraints can be understood as being derived from a finite basis under concatena- tion. This contrasts with (and complements) earlier analyses of autosegmental representa- tions, where these constraints were presented as axioms of the grammatical system. Empir- ically motivated examples are provided. </chunk></section><section><heading>1 Introduction </heading><chunk>Autosegmental phonology represents words with graph structures. This paper provides a new way of defining the set of valid autosegmental represen- tations through concatenating a finite set of graph primitives with particular properties. This bottom- up approach to formalizing autosegmental repre- sentations (henceforth APRs) contrasts with the top-down, axiomatic approach of previous formal- izations of APRs (Goldsmith, 1976; Bird and Klein, 1990; Coleman and Local, 1991; Kornai, 1995). However, we show that APR graphs constructed in the way we define hold to these axioms. One advan- tage to this perspective is that it brings out the string- like quality of APRs, in that they can be generated by the concatenation of a finite set of primitives. Fur- thermore, it shows that two putatively universal con- straints, the Obligatory Contour Principle and the No Crossing Constraint (see below), are guaranteed to hold of autosegmental representations provided the graph primitives also obey these constraints. In other words, concatenation preserves these proper- ties. Finally, the empirical generalization that lan- guages may exhibit unbounded spreading but not unbounded contours is naturally expressed by this finite set of primitives, as spreading is derivable through concatenation but the only available con- tours are those found in the set of graph primitives. In short, important properties of autosegmental rep- resentations of words can be understood as being de- rived from a finite basis under concatenation. Goldsmith (1976) originally defined APRs as graphs. Likewise, this paper models APRs us- ing graphs representing both the associations and precedence relations of APRs. We apply estab- lished graph-theoretic methods to APRs, in par- ticular graph concatenation, as defined by Engel- friet and Vereijken (1997). Engelfriet and Vereijken (1997) generate all graphs from concatenation and sum operations and a finite set of primitives. What is proposed here is a much weaker version of this idea, using concatenation only to build a specific class of graphs from a set of primitives. In doing so, it is shown how the properties of structures in the gener- ated class derive from the operation and the primi- tives. As detailed in the next section, there are several properties that most researchers agree are essential to APRs. One is that their composite autosegments 139 are divided up into disjoint strings called tiers, with associations linking autosegments on different tiers. Second, the No-Crossing Constraint (NCC) (Gold- smith, 1976; Hammond, 1988; Coleman and Local, 1991) states that these associations cannot cross; i.e., they must respect the precedence relations on each tier. Finally, the Obligatory Contour Prinicple (OCP) (Leben, 1973) states that on the melody tier adjacent autosegments cannot be identical. Formal treatments of these properties, starting with Goldsmith (1976), state these properties as ax- ioms. For example, Bird and Klein (1990) pro- vide a model-theoretic definition of APRs given a particular interpretation of association as overlap, and state axioms restricting the overlap relation. More recently, Jardine (2014) axiomatizes the NCC and one-to-one association in monadic-second order logic. Kornai (1995)s treatment defines concatena- tion operations similar to the one given here, but his definition of APRs as bistrings does not derive from these operations. As a result, key properties like the NCC must be specified as axioms. Instead, the current paper shows that the NCC and OCP can be derived by a concatenation oper- ation alone, given a well-defined set of primitives. This paper is structured as follows. 2 details the set of properties phonologists deem important for APRs. 3 gives the relevant mathematical prelimi- naries, and 4 defines APRs as graphs and how the properties in 2 can be formalized as axioms. 5 defines a concatenation operation over graphs, and 6 proves how APR graphs derived using this con- catenation operation obey the relevant axioms from 4. 7 then shows how to describe some common natural language phenomena using concatenation, as well as some phenomena that raise issues for con- catenation. 8 reviews the advantages of viewing APRs through concatenation and discusses future work, and 9 concludes. </chunk></section><section><heading>2 Basics of Autosegmental Phonology </heading><chunk>Autosegmental phonology (AP) (Goldsmith, 1976; Goldsmith, 1979; Clements, 1976; McCarthy, 1979; McCarthy, 1985) has been a widely adopted theory of phonological representations in which phonolog- ical units, called autosegments, appear on one of some finite set of strings, or tiers, and related to au- tosegments on other tiers by association. Such au- tosegmental representations (APRs) are usually de- picted with the tiers as vertically separated strings of symbols and the association relation shown as lines drawn between autosegments, as in (1) below. a. a b b. a c. H L c c d (1) The core insight APRs express is that a single au- tosegment on one tier may be associated to multi- ple autosegments on another tier, as in (1). For pur- poses of exposition, this paper focuses on two-tiered APRs: a melody tier, which carries featural infor- mation, and a timing tier, which represents how fea- tures on the melody tier are pronounced in the lin- ear speech stream. For example, in tonal phonology, APRs often comprise a melody tier over the symbols {H, L} for high and low tones and a timing tier over {} for morae (the timing unit most commonly as- sociated with tone). The APR in (1c) thus represents a high-toned mora followed by a falling tone mora. Thus, the insights of autosegmental phonology can be studied minimally with two-tier APRs, and so this paper focuses on two-tier APRs. However, in practice, APRs often use more than two tiers. As we explain at the appropriate points throughout the paper, the concepts discussed here can be straight- forwardly applied to AP graphs with multiple tiers. Two principles have been seen as crucial to con- straining the theory of APRs. One is the No Cross- ing Constraint (NCC) (Goldsmith, 1976; Hammond, 1988; Coleman and Local, 1991), which states that if autosegment a is associated to autosegment y, no autosegment b which follows a on its tier may be as- sociated to an autosegment x which precedes y. An example APR violating the NCC is given in (2a). The other principle is the Obligatory Contour Prin- ciple (OCP), which states that on each tier, adjacent autosegments must be different (Leben, 1973; Mc- Carthy, 1986). The APR in (2b) violates the OCP. a. H L b. H H (2) Formal definitions of the NCC and OCP will be given in the following section, after we have defined 140 APRs explicitly in terms of graphs. The NCC is usu- ally considered to be inviolable, where the OCP is considered violable by some authors (Odden, 1986). This paper treats the OCP as an inviolable principle, although this point is returned to in 8. It is often, but not always, assumed that the sets of autosegments which are allowed to appear on each tier are disjoint. This assumption is usually adhered to in tonal and featural APRs, but not always in mor- phological APRs in which separate tiers represent separate morphemes (a la McCarthy (1979)). Here, we assume that the sets of elements allowed to ap- pear on each tier are disjoint, and leave theories of APRs which allow a particular autosegment to ap- pear on multiple tiers for future work. </chunk></section><section><heading>3 Preliminaries </heading><chunk>Let N represent the natural numbers. Given a set X of elements, a partition P is a set {X 0 , X 1 , ...X n } of nonempty subsets or blocks of X such that X is the union of these blocks and for each X i , X j P , X i X j = . P induces an equivalence relation P over X such that for all x, y X, x P y iff for some X i P , x X i and y X i . We also say P partitions X into P . A partition P is said to refine another partition P iff every block of P is a union of blocks of P . We also say P is then finer than P . If R is a relation on X then let R denote the finest equivalence relation on X containing R. If is a finite alphabet of symbols, then de- notes the set of all strings over that alphabet, in- cluding the empty string . We consider here alpha- bets structured by partitions. We refer to a partition T = {T 0 , T 1 , ..., T n } of as a tier partition over , and refer to some block T i in T as a tier alphabet. A labeled mixed graph is a tuple V, E, A, l where V is a set of nodes, E is the set of undirected edges, A is the set of directed edges (or arcs), and l : V is a total labeling function assigning each node in V a label in an alphabet . For elements of the set V we will use early elements in N. An undi- rected edge is a set {x, y} of cardinality 2 of nodes x, y V , and a directed edge is a 2-tuple (x, y) of nodes in V . When not obvious from context, the el- ements of a graph G will be marked with subscripts; e.g., V G . Let G , the empty graph, refer to the graph , , , . Unless otherwise noted, all graphs in this pa- per are labeled mixed graphs, and thus will simply be referred to as graphs. All graphs are also as- sumed to be simple graphs without multiple edges; {x, y} E implies (x, y) A, and (x, y) A im- plies {x, y} E. Let GR() denote the union of {G } with all graphs whose labels are in . A graph H is a subgraph of a graph G if V H V G , E H E G , A H A G , and l H l G . A sub- graph H of G is an induced subgraph if for some subset X of V G , V H = X and for all x, y X, {x, y} E G iff {x, y} E H and (x, y) A G iff (x, y) A H . In other words, H has exactly the edges in G that appear between the nodes in X. We say X induces H and also write G[X] for H. By a partition of G we refer to some set {G[V 0 ], G[V 1 ], ..., G[V n ]} where {V 0 , V 1 , ..., V n } is a partition of V . </chunk></section><section><heading>4 APRs as graphs </heading><chunk>Here we define autosegmental graphs (APGs), or explicit graph representations of APRs. In this sec- tion, the set of valid APGs is defined axiomatically based on the phonological principles discussed in 2. In 6.2 we show that these principles can all be derived from graph concatenation. For an APG G, A represents the ordering relation on each tier, and E represents the association relations between them. 1 We first define the tiers as subgraphs of G that are string graphs for which A represents the successor relation (Engelfriet and Hoogeboom, 2001). a b a b Figure 1: A string graph Let be the reflexive, transitive closure of A. That is, for any x, y V , if x y then either x = y or there is a directed path from x to y. Definition 1 A graph is a string graph if E = and its relation is a total order on V . 1 It should be noted that linguists often leave the precedence relation on each tier as implicit or otherwise distinct from the model of associations (see Coleman and Local (1991) for an overview). However, with precedence directly in the graph, an APG represents all of the information in an APR, and thus this information can be studied by established graph-theoretic tech- niques, such as the graph concatenation considered here. 141 Let A be the smallest equivalence relation that results from the symmetric closure of . The first axiom says A partitions V into two tiers. Axiom 1 V is partitioned by A into at most two sets V 0 , V 1 such that G[V 0 ] and G[V 1 ] are string graphs. V 0 and V 1 are the tiers of G. The second axiom, related to Axiom 1, is that the partition of G into tiers respects some partition of . Axiom 2 There is some tier partition T = {T 0 , T 1 } over such that l forms a morphism from T to A such that l(x) T l(y) iff x A y. Axiom 2 corresponds to the principle discussed in 2 that each kind of autosegment may only ap- pear on a particular tier. Note that a tier in G thus corresponds to a tier alphabet in T . For notational brevity, we mark this with matching subscripts; e.g., V 0 is the subset of V s.t. for all v V 0 , l(v) T 0 . Axiom 3 governs the general form of associations. Axiom 3 For all {x, y} E, x A y. This simply states that the undirected edges, which again represent associations, must have one end in each tier. Thus, as noted by Coleman and Local (1991), the set of associations between two tiers in an APG forms a bipartite undirected graph V, E, l where the two parts are the tiers V 0 and V 1 . Having defined the structure of APGs in Axioms 1 through 3, we now define the NCC and OCP. Axiom 4 (NCC) For all u, v, x, y V , if {u, x}, {v, y} E and u v, then x y. Similar axioms have also been defined by Bird and Klein (1990), Kornai (1995), and Jardine (2014). Finally, Axiom 5 defines the OCP. Recall that the OCP only holds at the melodic level, so we choose only one of the tiers V m for the OCP to hold. Axiom 5 (OCP) For one tier V m , for all x, y V m , (x, y) A implies l(x) = l(y). This concludes the axioms for APGs. For an alphabet and tier partition T = {T m , T t } over , let AP G(, T ) denote the class of APGs obey- ing the tier partition T of , where for each G AP G(, T ), l maps elements in the tier V m adher- ing to Axiom 5 to T m . 2 6 shows how to derive 2 Note that E is not required to be nonempty; that is, APGs with no association lines are allowed. This can model, for ex- ample, underlying APRs with unassociated melodies. these axioms from the concatenation, as defined in the following section, of an alphabet of graph prim- itives with certain properties. These axioms can be extended to graphs with more than two tiers. Instead of binary partitions, and V could be partitioned into {T 0 , T 1 , ..., T n } and {V 0 , V 1 , ..., V n }, respectively. In this case, Ax- iom 3 would specify a single tier in which all undi- rected edges must have one end. Axiom 5 would then hold for all tiers besides this tier. This re- sults in paddle-wheel APRs, like those defined by Pulleyblank (1986). Theories of feature geometry (Archangeli and Pulleyblank, 1994; Clements and Hume, 1995; Sagey, 1986) could also be accommo- dated for by positing additional structure on T . This, however, shall be left for future work. </chunk></section><section><heading>5 Concatenation </heading><chunk>This section defines a concatenation operation () based on that of Engelfriet and Vereijken (1997). Engelfriet and Vereijken (1997)s operation merges nodes of graphs with specified beginning and end points; here, we use the tier structure to determine how the graphs are concatenated. We thus define G 1 G 2 for two graphs G 1 , G 2 in GR() given a tier partition T = {T m , T t } over . The basic idea is to connect, if they exist, the last node of the first graph and the first node of the second graph for each tier. Such end nodes with identical labels in the T m tier alphabet are merged, whereas end nodes with labels in the timing tier alphabet and nodes with nonidentical labels in the melody tier alphabet are connected via a directed edge. As shown in 6.2 and 7, it is this merging that derives both the OCP and spreading for APGs constructed this way. As the concatenation operation is defined over graphs in GR(), it is at first very general and not of any phonological interest. However, we show in 6 that concatenation can be used to define a set of APGs that follow the axioms in 4, as shown in 6.2. </chunk></section><section><heading>5.1 Definition </heading><chunk>We assume that G 1 and G 2 are disjoint (i.e., that V 1 and V 2 are disjoint sets)if G 2 is not disjoint with G 1 , then we replace it with a graph isomorphic to G 2 that is disjoint with G 1 . We use two partial functions first : GR() 142 G 1 = a 0 b 1 c 2 G 2 = b 3 c 4 Figure 2: Two graphs in GR() T N and last : GR() T N which pick out the first and last nodes on a particular tier in a graph. 3 Recall that V i is the subset of V s.t. for all v V i , l(v) T i . Formally, first(G, T i ) def = v V i s.t. v V i , v v if such a v exists; otherwise it is undefined. Similarly, last(G, T i ) def = v V i s.t. v V i , v v if such a v exists; other- wise it is undefined. We shall sometimes refer to first(G, T i ) (resp. last(G, T i )) as the first (last) node of G for tier alphabet T i . Example 1 Consider the alphabet = {a, b, c} and the tier partition T = {T m = {a, b}, T t = {c}}. Take graphs G 1 and G 2 where V 1 = {0, 1, 2} and V 2 = {3, 4} with edges and label- ing as in Figure 2 Node indices are given as sub- scripts on the node labels. last(G 1 , T m ) = 1, and first(G 2 , T t ) = last(G 2 , T t ) = 4. The concatenation operation combines the graphs, either merging or drawing arcs between the first and last nodes on each tier, depending on their labels. The operation can be broken down into multiple steps as follows. First, we define the graph G 1,2 as the pairwise union of G 1 and G 2 . We denote V 1 V 2 with V 1,2 and so on. G 1,2 = V 1 V 2 V 1,2 , E 1 E 2 E 1,2 , A 1 A 2 A 1,2 , l 1 l 2 l 1,2 (3) Next, two binary relations over the nodes of G 1,2 are defined. R pairs the last element in G 1 and the first element in G 2 of each tier. R ID is a restriction on R to pairs who share identical labels, excluding nodes whose labels are in T t . R def = { (v, v ) V 1,2 V 1,2 | v = last(G 1 , T i ), v = first(G 2 , T i ), for some T i T } (4) 3 That these are partial functions will be most useful for deal- ing with graphs with no nodes on a particular tier; for example the empty graph, which is discussed below. R ID def = { (v, v ) R | l(v) = l(v ), l(v) T t } (5) We also often refer to the complement of R ID with respect to R; R ID def = R R ID . We can then use Engelfriet and Vereijken (1997)s merging operation which reduces a graph G with any relation R V V over its nodes. Informally, nodes which stand in the relation are merged; ev- erything else stays the same. Given any such re- lation R, we consider R , the finest equivalence relation on V containing R. In the usual way, let [v] R = {v |v R v }. Here, we use R ID , which assigns each node its own equivalence class, except for pairs (v, v ) R ID of last and first nodes with identical labels, which are lumped together. Example 2 Continuing with G 1 and G 2 from Ex- ample 1, G 1,2 is given in Figure 3a. For G 1,2 , R = {(1, 3), (2, 4)}, R ID = {(1, 3)}, and so R ID = {(2, 4)}. The equivalence classes for R ID , {{0}, {1, 3}, {2}, {4}}, are shown in Figure 3b. a. a 0 b 1 c 2 b 3 c 4 b. a 0 b 1 c 2 b 3 c 4 Figure 3: (a) G 1,2 and (b) RID in G 1,2 Given a graph G and a relation R V V , Engelfriet and Vereijken (1997) define V /R = {[v] R |v V }. This simply merges the nodes of V based on the equivalence relation R . G/R can then be defined as the graph reduced by this merged set of nodes; V /R, E, A, l. The final step is to add precedence arcs to connect R ID , the unmerged last and first nodes in G 1,2 /R ID . Again, R ID is the pairs of last/first nodes on the melody tier that are not identical and the last/first pair on the timing tier, which are never merged. Definition 2 (Concatenation of APGs). The con- catenation G 1 G 2 of graphs G 1 and G 2 in GR() is: G 1 G 2 = V 1,2 /R ID , E 1,2 , A 1,2 R ID , l 1,2 Example 3 The concatenation of G 1 and G 2 is given in Figure 4. The node numbered 1, 3 rep- resents the nodes from Fig. 3 which have been 143 merged. Node also the added directed edge (2, 4) from R ID in Example 2. a 0 b 1,3 c 2 c 4 Figure 4: G 1 G 2 Technically, the resulting set V 1,2 /R ID is a set of sets of nodes representing the equivalence classes of R ID ; for example, V 1,2 /R ID in Example 3 is {{0}, {1, 3}, {2}, {4}}. Represented strictly in this way, successive concatenations will yield sets of sets of sets of nodes, ad infinitum. For example, concate- nating a third graph, such as G 3 in Figure 5 below, to G 1 G 2 would further merge node {1, 3} with node 5 in G 3 . Strictly speaking, the resulting node is {{1, 3}, {5}}. For clarity, we instead represent each node in this case as the union of the elements of each member of its equivalence class, e.g. {1, 3, 5} for the concatenation (G 1 G 2 ) G 3 in Figure 5. This convenient renaming flattens out the nested sets. It does not result in any loss of generality be- cause union is associative. Also, it will be useful later when showing concatenation is associative for the particular class of graphs described in 6. G 3 = b 5 c 6 (G 1 G 2 ) G 3 = a 0 b c 2 c 4 c 6 {1, 3, 5} Figure 5: Concatenating a third graph G 3 Importantly, the relations R and R ID do not de- pend on a binary partition over ; they only require that one partition T t for the timing tier be specified. Thus, while the examples given here focus on two tiers, this operation is defined for graphs represent- ing APRs with multiple melody tiers. </chunk></section><section><heading>5.2 Properties </heading><chunk>This section proves two important properties of con- catentation, that G is the identity for , and that for any tier in both G 1 and G 2 , G 1 G 2 contains a string graph corresponding to those tiers. Theorem 1 G is the identity element for the op- eration. That is, for any G GR(), G G = G G = G. Proof: Let G = V, E, A, l. We first consider G G. Recall that the concatenation of two graphs is a modification of their disjoint union. From the properties of the union operation, we know that the disjoint union of G and G is G. Note that first(G , T i ) and last(G , T i ) are undefined for all T i T , because the set of nodes is empty in G . Thus, R = , and so R ID = R ID = . Because R ID = , V /R = V , because the smallest equiva- lence relation containing is =. Thus, G G = (V /R) = V, (E ) = E, (A ) = A, (l ) = l = G G G = G is similarly derived. The next lemma shows that concatenation pre- serves the string graph properties of any tiers in G 1 and G 2 . This is important for showing the associa- tivity of concatenation under certain graph classes, as will be discussed in 6. Lemma 1 Let U i and V i denote the set of all nodes in G 1 and G 2 , respectively, with labels in some member T i of T . If G 1 [U i ] and G 2 [V i ] are string graphs, or if U i is empty and G 2 [V i ] is a string graph, or if G 1 [U i ] is a string graph and V i is empty, then (G 1 G 2 )[W i ] is a string graph, where W i is the set of all nodes in G 1 G 2 whose labels are in T i . Furthermore, for any T i , if v = first(G 1 , T i ), then first(G 1 G 2 , T i ) is the unique node in G 1 G 2 which contains v, and likewise for last(G 2 , T i ). Proof: This follows immediately from the defini- tion of concatenation if G 1 [U i ] is a string graph and V i is empty, because then first(G 2 , T i ) will be undefined and no member of U i will appear in R, and thus all will appear in G 1 G 2 unmodified and with no new arcs associated with them. Thus, G 1 [U i ] = (G 1 G 2 )[W i ] and so both are string graphs. The proof for the case in which U i is empty and G 2 [V i ] is a string graph is very similar. For the final case, recall that a graph G is a string graph iff its set of arcs A forms a total or- der on its nodes V . For the case G 1 [U i ] and G 2 [V i ] are string graphs and v 1 = last(G 1 , T i ) and 144 v 2 = first(G 2 , T i ), then (v 1 , v 2 ) appears in either R ID or R ID . If the pair is in R ID , v 1 and v 2 are merged into a node v 1,2 and no new arcs will be in- troduced to the set A i of the arcs in (G 1 G 2 )[W i ]. So for the arc (v 1 , v 1 ) from G 1 [U i ] and (v 2 , v 2 ) from G 2 [V i ], the corresponding arcs in A i are (v 1 , v 1,2 ) and (v 1,2 , v 2 ), respectively, which maintains the to- tal orders of both U i and V i . If (v 1 , v 2 ) R ID , then (v 1 , v 1 ), (v 1 , v 2 ), and (v 2 , v 2 ) are all in A i , which also mantains the total order. That for v = first(G 1 , T i ), first(G 1 G 2 , T i ) is the unique node which contains v follows directly from the fact that the total order on U i is maintained. Likewise for v = last(G 2 , T i ) and V i . These properties allow us to treat sets of graphs parallel to sets of strings, as the next section shows. </chunk></section><section><heading>6 APGs derived from concatenation </heading></section><section><heading>6.1 Alphabets of graph primitives </heading><chunk>As Engelfriet and Vereijken (1997) observe, given a concatenation operation a class of graphs can be seen as an interpretation of a set of strings, where each symbol in the string corresponds to a graph primitive. We now define an APG graph primitive. Definition 3 Over an alphabet and tier partition T = {T t , T m }, an APG graph primitive is a graph G GR() which has the following properties: a. V t is a singleton set {v t } b. G[V m ] is a string graph or is empty c. All e E are of the form {v m , v t }, v m V m We can then treat a finite set of primitives like an alphabet of symbols: Definition 4 An alphabet of graph primitives over GR() is a finite set of symbols and a naming function g : GR(). An alphabet of APG graph primitives is thus for which for all , g() satisfies Definition 3. Example 4 As in the previous examples, consider the alphabet = {a, b, c} and the tier partition T = {T m = {a, b}, T t = {c}}. The alphabet of graph primitives = {a, b, d}, where its naming function g is defined as in Figure 6, is an alphabet of APG graph primitives. g(a) = a c g(b) = b c g(d) = a b c Figure 6: An example and g The strings in thus represent a class of graphs, which we will call AP G(). We define AP G()by extending g to strings in . Definition 5 For an alphabet of graph primitives with naming function g, extend g to strings in as follows. For w , g(w) def = G if w = g(u) g() if w = u, u , AP G() is thus {g(w)|w }. </chunk></section><section><heading>6.2 Derived properties </heading><chunk>We now show that if is an alphabet of APG graph primitives, then AP G() has a number of desirable properties. The following assumes is an alphabet of APG graph primitives. First, we prove the follow- ing theorem stating that all graphs in AP G() fol- low Axioms 1 through 3 from 4 regarding the gen- eral structure of APGs. Theorem 2 For any G AP G(), G satisfies Ax- iom 1 (that A partitions V into at most two sets V 0 and V 1 such that G[V 0 ] and G[V 1 ] are string graphs), Axiom 2 (that the tiers of G correspond to the partition T ), and Axiom 3 (that the ends of all undirected edges are between different tiers). Proof: That G satisfies Axioms 1 and 2 follows di- rectly from parts (a) and (b) of Definition 3 and the fact that concatenation only adds arcs between nodes whose labels are in the same T i T . That G[V 0 ] and G[V 1 ] are string graphs follows from parts (a) and (b) of Definition 3 and Lemma 1. That G follows Axiom 3 follows directly from Part (c) of Definition 3 and the fact that concatena- tion adds no new undirected edges to E. Next, concatenation is associative over AP G() . The following lemma allows one to prove Theo- rem 3 (associativity) below. 145 Lemma 2 For any u, v denote g(u), g(v) AP G() with G u and G v respectively. Then for any , G u (G v G ) = (G u G v ) G . Proof: Let G = V, E, A, l denote (G u G v ) G and G = V , E , A , l denote G u (G v G ). That E = E and l = l follow from Definition 2 of concatenation and associativity of union. To show V = V , there are seven relevent cases to consider. Let V u , V v , and V denote the sets of nodes for G u , G v , and G , respectively, and let v u de- note a node in V u , etc. As merging is accomplished through grouping nodes into equivalence classes,all nodes in V or V thus correspond to either Cases 1 3 {v u }, {v v }, {v }, Cases 46 {v u , v v }, {v v , v }, {v u , v }, or Case 7 {v u , v v , v } (recall from 5 we do not distinguish between nodes representing sets and nodes representing sets of sets). As per the definition of concatenation, V = ((V u V v )/R ID-u,v V )/R ID , where R ID-u,v is de- fined over V u V v and R ID over (V u V v )/R ID-u,v . Likewise, V = (V u (V v V )/R ID-v, )/R ID . Cases 13. We first establish that when v V corresponds to a singleton set that v V . Con- sider the case when v V corresponds to {v v }, when v v has not been merged. For V , this is exactly the case in which there is no (v u , v v ) R ID-u,v nor a ({v v }, v ) R ID . We show that this en- tails that there is neither a (v u , {v v }) R ID nor a (v v , v ) R ID-v, , and so {v v } V . There is no ({v v }, v ) R ID either when {v v } is not the last node in G u G v for any T i or there is no v with which it can merge. If {v v } is not the last node in G u G v for any T i , then v v is not the last node in G v for any T i , as by Theorem 2 and Lemma 1 the last node for T i in G u G v must be the unique set which includes the last node for T i in G v . If there is no v to merge with {v v }, then there is no v to merge with v v either. Thus, there cannot be a (v v , v ) R ID-v, . Similarly, it follows that there is no (v u , {v v }) R ID . If there is no (v u , v v ) R ID-u,v , then either v v is not the first node in G v or there is no v u with which it can merge. Thus, ei- ther {v v } is not the first node in G v G (again by Lemma 1) or there is no node v u to merge with {v v }, and so there is no (v u , {v v }) R ID . As there is nei- ther a (v u , {v v }) R ID nor a (v v , v ) R ID-v, , then {v v } V . The proofs that v V implies v V when v corresponds to {v u } and {v } are very similar. The proofs that v V implies v V for all three cases are identical. The remaining cases deal with merged nodes. Cases 46. Consider the case in which v V is {v u , v v } corresponding to merged nodes from V u and V v . This is the case in which (v u , v v ) R ID-u,v but there is no ({v u , v v }, v ) R ID for any v . As before, if {v u , v v } cannot be merged with some v , then there is no v to merge with v v . Further- more, if (v u , v v ) R ID-u,v , then v u is the last node in G u and v v is the first node in G v for some T i . By Lemma 1, then {v v } is the first node in G v G for T i , and so (v u , {v v }) R ID . Thus, {v u , v v } V . The proof that v V implies v V when v = {v v , v } is very similar, as it is for v = {v u , v }. The latter is a special case in which V v has no nodes for some T i , but v u and v are com- patible to merge. Case 7. For v = {v u , v v , v }, both (v u , v v ) R ID-u,v and ({v u , v v }, v ) R ID . If ({v u , v v }, v ) R ID , then through Lemma 1 (v v , v ) R ID-v, and then (v u , {v v , v }) R ID , so {v u , v v , v } V . The proofs that v V im- plies v V for these cases are identical. That A = A is very similar to the proof for V = V . Let A i denotes the set of arcs in g( i ). Then A = (A u A v R IDu,v ) A R ID , where R IDu,v is defined over (V u V v )/R ID-u,v and R ID is defined over ((V u V v )/R ID-u,v V )/R ID , and V u V v A = (A u (A v A R IDv, ) R ID ), where R IDv, and R ID are defined parallel to R IDu,v and R ID . As union is associative, it is suf- ficient to show that every pair (v u , v v ) R IDu,v has a corresponding pair (v u , {v v }) or (v u , {v v , v }) in R ID and vice versa, and that every pair ({v v }, v ) or ({v u , v v }, v ) in R ID has a corresponding pair (v v , v ) R IDv, , and vice versa. Both of these follow from the fact that V = V and Lemma 1 in the same way as merging nodes above. Next it is shown that graph concatenation is as- sociative over arbitrary graphs in AP G() with the same kind of inductive argument which establishes concatenation is associative over strings. Theorem 3 The operation is associative over graphs in AP G(). For any u, v, w denote g(u), g(v), g(w) AP G() with G u , G v , G w re- 146 spectively. Then G u (G v G w ) = (G u G v ) G w . Proof: The proof is by induction on the size of w. For the base case, when w = , G w = G . Then G u (G v G w ) = G u (G v G ), which equals G u G v by Theorem 1. It follows, again by Theorem 1, that (G u G v ) G . Hence the base case is proved. Next we assume the inductive hypothesis that associativity holds for strings of length n and we consider any w of length n + 1. Clearly there exists x of length n and so that w = x. Then G u (G v G w ) = G u (G v (G x G )). By Lemma 2, this equals G u ((G v G x ) G ), which again by Lemma 2, equals G u (G v G x )) G . Then, by the induction hypothesis, we have ((G u G v ) G x ) G , which again by the induction hypothesis, yields (G u G v ) (G x G ). This is of course is (G u G v ) G w . The next theorem states that any G AP G() follows the NCC. Theorem 4 For any G AP G(), G satisfies the NCC (Axiom 4). Proof: The proof is by recursion on the length of w . G trivially satisfies the NCC because it has no nodes. For g() for any , Definition 4 states that there is only one node v t in V t and this node must be one of the endpoints for each edge in E. Thus for any two edges {x, y} and {x , y } in g() where x x , it must be the case that y = y = v t , because directed edges only occur between nodes in tier V m . Thus, any g() satisfies the NCC. Next we assume it holds for w of length n and consider any w , . Then g(w) satisfies the NCC because the graph concatenation operation does not add any undirected edges and because, by Lemma 1 concatenation preserves the order of each tier in g(w) and g(). The final theorem states that any G AP G() follows the OCP if the graph primitives do. Theorem 5 If g() for all satisfy the OCP (Axiom 5), then for any G AP G(), G satisfies Axiom 5. Proof: The proof is again by recursion on the length of w . The OCP is trivially satisfied for G since it contains no nodes or arcs. The case when |w| = 1 is given as the condition of the theorem. Assume that every w of length n satisfies the OCP. Now consider G = g(w) with w of length n and . To see that G u G satisfies the OCP, recall from Definition 2 of graph concatenation that the set of arcs for G 1 G 2 is equal to A 1,2 R ID ; i.e., the union of A 1 and A 2 and R ID . By definition R ID only includes pairs of nodes (x, y) s.t. l(x) = l(y), so if G 1 satisfies the OCP and G 2 satisfies the OCP R ID will not add any arcs on V m which violate the OCP (recall that the OCP only holds for tier V m ), and so G 1 G 2 will also satisfy the OCP. Thus, the merging part of the concatenation pre- serves the OCP. One may wonder why the OCP is built in to the concatenation operation this way, in- stead of using string-like concatenation and then in- voking a constraint that merges adjacent, like nodes in the resulting graph. Such a method, though, can- not capture violations of the OCPall would be merged. The next section shows that the concate- nation operation defined here can capture violations by concatenating OCP-violating graph primitives. This section has thus proved the important prop- erties of AP G(). We now show how such an AP G() can be used to model autosegmental phe- nomena in natural language phonology. </chunk></section><section><heading>7 Analysis of natural language phenomena </heading><chunk>In this section we examine the extent to which the analysis presented here accounts for common and uncommon phenomena in phonological theory. The first two subsections examine spreading and con- tour tones, respectively, and demonstrate how both phenomena can be effectively represented with a AP G() for some . It is also shown that the empirical generalization that there are only finitely many contour tones present in any given language is an automatic consequence of the finite alphabet and the concatenation operation. The third subsection addresses the few cases where OCP violations may be necessary to prop- erly describe the language. It is sketched out how these cases could be accounted for by using spe- cial graph primitives or a second concatenation op- eration. Similarly, the fourth subsection addresses 147 underpecification and floating tones. We conclude that these concepts can be represented in this ap- proach. The caveat is that it is also observed as a consequence that gapped structures are also permit- ted. Again, we note that such gapped structures are also permitted with axioms given in 4 approaches above, and we discuss how a different concatenation operation may address this. </chunk></section><section><heading>7.1 Spreading </heading><chunk>The merging of nodes on the melody tier models autosegmental spreading, in which one melody unit is associated to more than one timing tier unit. A classic example is Mende (Leben, 1973). Mende nouns separate into tone categories, three of which are shown in Table 1. The first rows show words whose syllables are all high-toned, the second rows show words whose syllables are all low-toned, and the third rows show words whose syllables start high and end low. In the following [  a] transcribes a high tone, [` a] a low tone, [ a] a falling tone. Monosyllables Disyllables k  O war p  El  E house kp` a debt b` El` E pants mb u owl ng  l` a dog Trisyllables h  aw  am  a waist kp` ak` al` three-legged chair f  el` am` a junction Table 1: Mende word tone An autosegmental analysis for this pattern is that a set number of melodies spread left-to-right over the tone-bearing units (TBUs; we assume that for Mende the TBU is the syllable, ) of a word, as in Table 2. For example, the falling tone words [mb u] owl and [f  el` am` a] junction have an HL melody. In this case, the H associates to the first syllable of the word, and the L associates to all remaining syllables. H k  Owar H h  aw  am  a waist HL mb u owl HL f  el` am` a junction Table 2: APRs for four Mende words The APRs in Table 2 can be generated with the al- phabet of APG graph primitives given in Figure 7. The alphabet is = {H, L, } and the tier partition T = {T t , T m } where T t = {} and T m = {H, L}. Note that for these APGs, we abstract away from consonants and vowels and focus on the TBU, . g(  ) = H g(` ) = L g( ) = H L Figure 7: and g for Mende The APGs corresponding to the trisyllabic forms are thus g(  ) and g(  ` ` ), as in Figure 8. H H L g(  ) g(  ` ` ) Figure 8: APGs for Mende APRs in Table 2 These spreading effects are achieved by, for ex- ample in g(  ), the like H nodes from each g(  ) merging during concatenation, resulting in a single H associated to multiple nodes (which are not merged, because T t ). Note that given , T , and g, we are able to generate APGs directly from the linear string of toned syllables. </chunk></section><section><heading>7.2 Contours </heading><chunk>Concatenation allows for unbounded spreading, as a single node on the melody tier may merge any number of times. In contrast, concatenation does not allow for unbounded contours, as timing tier nodes do not merge. Figure 9 shows how concatenation obtains APGs corresponding to the APRs for the Mende words [mb u] owl and [ny` ah a] woman. H L L H L g( ) g(` ) Figure 9: APGs for Mende contours 148 Importantly, any set of graphs is going to have a bound on the number of melody units a contour can have, which follows directly from the fact that is finite, that each element of has exactly one node on V t , and so concatenation never creates new con- tours. Thus, for the example we have been using for Mende, the graph in Figure 10 is not in AP G(). H L H L Figure 10: A graph not in AP G() While this is a natural property of graphs in AP G(), the axiomatic approach to defining APRs requires a further axiom stating that for any lan- guage, the number of contours must be bound by some n. To our knowledge, the only explicit formal- izations of such a constraint are by Jardine (2014) and Yli-Jyr  a (2013) (the latter requiring that n = 2). </chunk></section><section><heading>7.3 Violations of the OCP </heading><chunk>As discussed in Odden (1986) and Meyers (1997), the OCP may not be an absolute universal. For ex- ample, Odden lists the contrasting APRs in Figure 11 for two nouns in Kishambaa (Odden, 1986, Fig. 13): a. H nyoka snake b. HH ngoto sheep Figure 11: OCP violating forms in Kishambaa This is partially motivated by the different surface pronunciation of the two forms: the first, Figure 11 (a) snake is pronounced with two level H tones, ny  ok  a, and 11 (b) sheep is pronounced with a H followed by a downstepped H; ng  o ! t  o. The corresponding graphs for these APRs, assum- ing the mora as the TBU, are given in Figure 12. Fig- ure 12 (a) corresponds to Figure 11 (a), and Figure 12 (b) to Figure 11 (b). Given an alphabet of graph primitives obeying the OCP, as the for Mende in Figure 7, Figure 12 (a) is in AP G(), but Figure 12 (b) is not, because it does not obey the OCP. Thus, Kishambaa is not de- scribable with such a graph set AP G(). a. H b. H H Figure 12: APGs for Kishambaa forms There are at least two solutions to admitting graphs like in Kishambaa. One is to introduce OCP- violating graph primitives, as in Figure 13. g( 1 ) = H g( 2 ) = H H Figure 13: A for Kishambaa Given this alphabet of graph primitives, the spreading Kishambaa graph in Figure 12 (a) is g( 1 1 ), and the OCP-violating (b) is g( 1 2 ). The graph primitives follow the linear pronunciation of the morae; g( 1 1 ) represents a sequence HH of two high-toned morae, and g( 1 2 ) a sequence H ! H of a high followed by a downstepped high. Another option is to define a second concatena- tion operation, in which there is no merging and di- rected edges are drawn between all last/first pairs. Spreading Kishambaa graph in Figure 12 (a) would be concatenated by the operation defined in this paper, and the OCP-violating Figure 12 (b) would be concatenated by this second no-merging opera- tion. We shall leave it up to future work to com- pare the theoretical and empirical benefits of these approaches to OCP violations. </chunk></section><section><heading>7.4 Underspecification and floating tones </heading><chunk>Some graph primitives in may not have any nodes in V m ; these represent underspecified timing units. H H g( 1 ) g( 2 ) g( 1 2 1 ) Figure 14: APGs with underspecification However, such underspecified graph primitives 149 can give rise to gapped structures via concatena- tion, as in g( 1 2 1 ) in Figure 14. This can be seen as an unwelcome consequence as some researchers have argued against gapped structures (Archangeli and Pulleyblank, 1994). One solution could be to use a second concatenation operation which does not merge nodes, instead only drawing directed edges between the end nodes on each tier. This appears identical to the operation proposed in 7.3 for deal- ing with OCP violations. Again, studying additional concatenation operations will be left for future work. Finally, graph primitives with more melody tier nodes than timing tier nodes can be used to generate floating tones, as in Figure 15. H H L H L H g( 1 ) g( 2 ) g( 2 1 ) Figure 15: Generating APGs with floating tones </chunk></section><section><heading>8 Dicussion </heading><chunk>The examples in the previous section show several advantages to considering APRs through concatena- tion. One, as seen in Mende, simple cases allow di- rect translation of strings into APRs. Second, con- catenation allows for unbounded spreading, as a sin- gle node on the melody tier may merge any num- ber of times. However, concatenation does not allow for unbounded contours, as timing tier nodes do not merge in this way. Thus, the number of contours is bounded by the number of graph primitives. This reflects the fact that languages exhibit unbounded spreading, but no language (to our knowledge) has an unbounded number of contour segments. There are several avenues for future work. It was already mentioned that the set of valid autosegmen- tal representations may be expanded by allowing a second concatenation operation. Also, while we have shown that every element of AP G() obeys the axioms in 4, it remains to be shown that for ev- ery graph which obeys those axioms, there is a finite alphabet which generates it. Future work can also study the nature of transfor- mations from underlying APGs with one alphabet to surface APGs with another (for instance it is known surface APGs can admit more contours than under- lying APGs through association rules). Another line of development concerns extend- ing the analysis to feature geometry (Clements and Hume, 1995; Sagey, 1986), in which association lines also link featural autosegments and organiza- tional nodes, such as PLACE. Deriving a set of such operations would require more complex primitives and additional marking on the tier partition T , to denote timing tier nodes, organizational nodes, and melody nodes. The concatenation operation would then need to be revised to be sensitive to this mark- ing. A more serious challenge would be adopting a concatenation-based framework for autosegmen- tal morphology, which as mentioned in 2, disposes of the requirement that autosegments of a particular type must appear on a particular tier. </chunk></section><section><heading>9 Conclusion </heading><chunk>In this paper we addressed the question of what is the set of valid autosegmental representations looks like. In contrast to previous research, which explored this question axiomatically, we showed that the autoseg- mental representations can be generated recursively and constructively from a finite set of graph primi- tives, a concatenation operation, and an identity ele- ment for concatenation, much in the same way that strings can be so generated. Hence, the theory of free monoids may be fruitfully applied to APRs. The advantages we wish to highlight are as fol- lows. First, we proved that provided the finite set of primitives obey the NCC and the OCP, the au- tosegmental representations will as well. Second, we showed it also follows naturally from the nature of the alphabet and concatenation that new contour tones cannot be generated ad infinitum. Finally, this method makes clear the stringlike nature of autoseg- mental representations, and that their properties can be viewed as a consequence of this nature. </chunk></section><section><heading>Acknowledgments </heading><chunk>The authors would like to thank three reviewers for their insightful comments and suggestions. The first author acknowledges support from a University of Delaware Graduate Research Fellowship. 150 </chunk></section><section><heading>References </heading><chunk>Diana Archangeli and Douglas Pulleyblank. 1994. Grounded Phonology. Cambridge: MIT Press. Steven Bird and E. Klein. 1990. Phonological events. Journal of Linguistics, 26:3356. G. N. Clements and Elizabeth V. Hume. 1995. The in- ternal organization of speech sounds. In John Gold- smith, editor, The handbook of phonological theory, pages 245306. Oxford: Blackwell. G. N. Clements. 1976. Vowel Harmony in Nonlin- ear Generative Phonology: An Autosegmental Model. Bloomington: Indiana University Linguistics Club Publications. John Coleman and John Local. 1991. The No Crossing Constraint in autosegmental phonology. Linguistics and Philosophy, 14:295338. Joost Engelfriet and Hendrik Jan Hoogeboom. 2001. MSO definable string transductions and two-way finite-state transducers. ACM Transations on Compu- tational Logic, 2:216254, April. Joost Engelfriet and Jan Joris Vereijken. 1997. Context- free graph grammars and concatenation of graphs. Acta Informatica, 34:773803. John Goldsmith. 1976. Autosegmental Phonology. Ph.D. thesis, Massachussets Institute of Technology. John Goldsmith. 1979. Autosegmental Phonology. Gardland Press. Michael Hammond. 1988. On deriving the Well-Formedness Condition. Linguistic Inquiry, 19(2):319325. Adam Jardine. 2014. Logic and the generative power of Autosegmental Phonology. In John Kingston, Claire Moore-Cantwell, Joe Pater, and Robert Staubs, edi- tors, Supplemental proceedings of the 2013 Meeting on Phonology (UMass Amherst), Proceedings of the Annual Meetings on Phonology. LSA. Andr  as Kornai. 1995. Formal Phonology. Garland Pub- lication. W. R. Leben. 1973. Suprasegmental phonology. Ph.D. thesis, Massachussets Institute of Technology. John J. McCarthy. 1979. Formal Problems in Semitic Phonology and Morphology. Ph.D. thesis, Mas- sachusetts Institute of Technology. John J. McCarthy. 1985. Formal Problems in Semitic Phonology and Morphology. New York: Garland. John J. McCarthy. 1986. OCP effects: gemination and antigemination. Linguistic Inquiry, 17:207263. Scott Meyers. 1997. OCP effects in Optimality Theory. Natural Language &amp; Linguistic Theory, 15(4):847 892. David Odden. 1986. On the role of the Obligatory Contour Principle in phonological theory. Language, 62(2):353383. Douglas Pulleyblank. 1986. Tone in Lexical Phonology. Dordrecht: D. Reidel. Elizabeth Sagey. 1986. The Representation of Features and Relations in Non-Linear Phonology. Ph.D. thesis, Massachusetts Institute of Technology. Moira Yip. 2002. Tone. Cambridge University Press. Anssi Yli-Jyr  a. 2013. On finite-state tonology with au- tosegmental representations. In Proceedings of the 11th International Conference on Finite State Meth- ods and Natural Language Processing, pages 9098. Association for Computational Linguistics. 151 </chunk></section></sec_map>