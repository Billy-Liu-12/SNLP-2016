<sec_map><section><chunk>Proceedings of the 14th Meeting on the Mathematics of Language (MoL 14), pages 7586, Chicago, USA, July 2526, 2015. c 2015 Association for Computational Linguistics A Synopsis of Morphoid Type Theory David McAllester TTI-Chicago mcallester@ttic.edu Abstract Morphoid type theory (MTT) is a type- theoretic foundation for mathematics support- ing the concept of isomorphism and the substi- tution of isomorphics. Unlike homotopy type theory (HoTT), which also supports isomor- phism, morphoid type theory is a direct exten- sion of classical predicate calculus and avoids the intuitionistic constructs of propositions- as-types, path induction and squashing. Al- though HoTT is capable of supporting clas- sical inference, MTTs thoroughly classical treatment is expected to be more comfortable for those who take a Platonic or realist ap- proach to the practice of mathematics. </chunk></section><section><heading>1 Introduction </heading><chunk>The central issue in both homotopy type theory (HoTT-Authors, 2013) and morphoid type theory (McAllester, 2014) is isomorphism. The notion of isomorphism in mathematics seems related to the notion of an application programming interface (API) in computer software. An API specifies what information and behavior an object provides. Two different implementations can produce identical be- havior when interaction is restricted to that allowed by the API. For example, textbooks on real analy- sis typically start from axioms involving multipli- cation, addition, and ordering. Addition, multipli- cation and ordering define an abstract interface the well formed statements about real numbers are limited to those that can be defined in terms of the operations of the interface. We can implement real numbers in different ways as Dedekind cuts or Cauchy sequences. However, these different im- plementations provide identical behavior as viewed through the interface the different implementa- tions are isomorphic as ordered fields. The axioms of real analysis specify the reals up to isomorphism for ordered fields. Peanos axioms (the second order version) similarly specify the structure of the natural numbers up to isomorphism. The general notion of isomorphism is best il- lustrated by considering dependent pair types. Here we will write a dependent pair type as PairOf (x : , y : [x]) where the instances of this type are the pairs Pair(x, y) where x is an in- stance of the type and y is an instance of [x]. The type of directed graphs can be written as PairOf (N : type, P : (N N ) Bool) where N is a type representing the set of nodes of the graph and P is a binary predicate on the nodes giving the edge relation. Two directed graphs Pair(N , P ) and Pair(M, Q) are isomorphic if there exists a bijec- tion from N to M that carries P to Q. Some bi- jections will carry P to Q while others will not. Two pairs Pair(x, y) and Pair(u, w) of a general dependent pair type PairOf (x : , y : [x]) are iso- morphic if there is a -isomorphism from x to u that carries y to w. Some -isomorphisms from x to u will carry y to w while others will not. This im- plies that to define isomorphism at general depen- dent pairs types we need that for any type , and for any two isomorphic values x and u of type , we can define the full set of -isomorphisms from x to u. An interesting special case is the full set of -isomorphisms from x to x. This is the symmetry group of x. 75 Both Homotopy type theory (HoTT) and mor- phoid type theory (MTT) are intended as type- theoretic foundations for mathematics supporting a concept of isomorphism. HoTT is an exten- sion of constructive logic while MTT is an exten- sion of classical predicate calculus. More specif- ically, HoTT is a version of Martin L  of type the- ory (Martin-L  of, 1971; Coquand and Huet, 1988; Sambin and Smith, 1998) extended to includes Vo- evodskys univalence axiom (HoTT-Authors, 2013). Martin-L  of type theory involves propositions-as- types and path induction, neither of which are used in MTT. To accommodate classical (nonconstruc- tive) inference, HoTT can be extended with a ver- sion of the law of the excluded middle. However, even in the classical version propositions continue to be represented as types rather than Boolean-valued expressions. To accommodate classical inference HoTT also includes squashing a technicality re- quired to allow propositions-types to be treated more like Boolean-valued expressions. In MTT all propo- sitions are Boolean-valued and there is no need for squashing. Perhaps the most significant difference between HoTT and MTT involves the abstraction barrier imposed on types. In MTT two types are type- isomorphic if there exists a bijection between them. In MTT two types with the same cardinality (num- ber of equivalence classes) cannot be distinguished by well-typed predicates on types. In HoTT, how- ever, types with the same cardinality can still be dis- tinguished by well-typed predicates. In HoTT two types are equivalent only when they have the same higher-order groupoid structure. For example, two graphs fail to be isomorphic unless the node types have the same higher order groupoid structure. This can be interpreted as implementation details of a type leaking from the abstraction barrier on types. This leakage interpretation is discussed more explic- itly in section 3. HoTT allows one to block the leakage of type im- plementations by squashing types to sets. A set is a type whose internal groupoid structure is effec- tively suppressed. One can construct the type of topological space whose point types are sets. In this case we get the familiar notion isomorphism (homeomorphism) where two topological spaces are homeomorphic if there is any bijection between their points that identifies their open sets. We can then define the groupoid of topological spaces to be the category consisting of the topological spaces and the homeomorphisms between them. This is the first order groupoid of topological spaces. If we take the point types of topological spaces to be first order groupoids rather than sets, and restrict the point bijections to functors, we get the second order groupoid of topological spaces. We can then define a third order groupoid and so on. In HoTT we can even have -order groupoids. In MTT the internal structure of types is ap- proached in a different way. In MTT natural map- pings are distinguished from general functions. For example, there is an isomorphism (a linear bijection) from a finite dimensional vector space to its dual. However, there is no natural isomorphism. Although not covered in this synopsis, MTT takes a function to be natural if it can be written as a lambda expres- sion. Lambda expressions (natural functions) have commutation properties not shared by general func- tions. Two types and are cryptomorphic (in the sense of Birkoff or Rota) if there exists a pair of nat- ural functions (lambda expressions) f : and g : such that f g and g f are both identity functions (viewed as functions on the isomorphism classes of and respectively). MTT does not at- tempt to handle higher order groupoid structure. This synopsis of MTT is preliminary and many of the features described here go beyond the fea- tures covered by soundness proofs in version 4 of (McAllester, 2014). This synopsis should be viewed as a plan, or program, for the next version of (McAllester, 2014). </chunk></section><section><heading>2 The Core Rules of Morphoid Type Theory </heading><chunk>Morphoid type theory starts from the syntax and se- mantics of classical predicate calculus. In sorted first order logic every term has a sort and each function symbol f specifies the sorts of its arguments and the sort of its value. We write f : 1 n to indicate that f is a function that takes n argu- ments of sort 1 , . . ., n respectively and which pro- duces a value of sort . The syntax of sorted first or- der logic can be defined by the following grammar where function and predicate applications must sat- 76 type j : type i for j &lt; i : type i x not declared in ; x : x : : type i : type i ( ) : type i f : e : f (e) : Bool : type i : Bool ; ; ; : Bool : Bool ( ) : Bool : Bool : Bool ; x : [x] : Bool (x : [x]) : Bool w : u : (w = u) : Bool Figure 1: Predicate Calculus Expressions. Here type 0 , type 1 , type 2 , . . . are distinct constants and is a constant denoting the empty context. The first two rules of the first row allow us to derive ; : type j : type j thereby declaring primitive types. We can then declare additional symbols such as c : or P : Bool. The requirement of j &lt; i in the first rule is needed to avoid Russels paradox. The second rule of the second row allows Boolean assumptions to be introduced into contexts. isfy the sort constraints associated with the function and predicate symbols. t ::= x | c | f (t 1 , . . . , t n ) ::= P (t 1 , . . . , t n ) | t 1 = t 2 | 1 2 | | x : [x] Note that in the above grammar the equality symbol = is subscripted with a sort to which it applies. The labeling of equality with sorts is important for the treatment of isomorphism. Given this basic grammar of terms and formulas it is standard to introduce the following abbreviations. ( ) x : [x] x : [x] !x : [x] x : [x] x, y : [x] [y] x = y (x : ) x : x = x We now replace the word sort with the word type. To define the set of well formed terms and formulas we need to specify primitive types and a set of constant and function symbols each with specified argument and value types. In formal type systems this is done with symbol declarations. We write t : to indicate that the symbol declarations in imply that t is a well-formed expression of type . For example we have the following. : type; : type; c : ; f : f (c) : : type; c : ; f : ; P : Bool P (f (f (c))) : Bool An expression of the form is called a se- quent where is called the context and is called the judgement. The sequent says that judge- ment holds in context . We allow a context to contain both symbol declarations and Boolean as- sumptions. For example we have : type; a : ; b : ; f : ; x : y : f (x, y) = f (y, x) f (a, b) = f (b, a) 77 : Bool : Bool ; ; : Bool : Bool : Bool : Bool : Bool : Bool ( ) x : [x] e : [e] ; x : [x] : Bool ; x : [x] x : [x] !x : [x] The(x : , [x]) : [The(x : , [x])] e : e = e u = w w = u u = w w = s u = s : type i ; x : e[x] : w = u , , and e[x] are pure e[w] = e[u] f, g : x : f (x) = g(x) f = g : type i x : y : [x, y] , , and [x, y] are pure f : x : [x, f (x)] Figure 2: Predicate Calculus Inference Rules. The first row is a complete set of rules for Boolean logic. A rule with two conclusions abbreviates two rules each with the same antecedents. The third rule in the second row handles definite descriptions (Hilberts -operator). An expression is pure if does not involve any of the constructs introduced in figure 6. The last row gives the axioms of extensionality and choice. In higher order predicate calculus the type system is extended to include not only primitive types but also function types and we can write, for example, P (f ) where we have f : and P : ( ) Bool. In the higher order case we can use the fol- lowing standard abbreviations due to Curry. 1 2 1 ( 2 ) f (a, b) f (a)(b) This extends in the obvious way to abbreviations of the form 1 n . Without loss of gen- erality we then need consider only single argument functions. Figure 1 gives a set of inference rules for forming the expressions of higher order predicate calculus. Each rule allows for the derivation of the sequent be- low the line provided that the sequents above the line are derivable. A rule with no antecedents is written as a single derivable sequent. Figure 2 gives inference rules for predicate cal- culus including definite descriptions of the form The(x : , [x]) (Hilberts -operator) and rules representing the axiom of extensionality and the ax- iom of choice. Figure 3 gives inference rules for dependent pair types, subtypes, and existential types. A dependent pair type has the form PairOf (x : , y : [x]) and is the type whose instances are the pairs Pair(x, y) where x is an instance of and y is an in- stance of [x]. A subtype expression has the form SubType(x : , [x]) where [x] is a Boolean expression. This expression denotes the type whose elements are those elements x in such that [x] holds. We let PairOf (x : , y : [x] s. t. [x, y]) 78 : type i ; x : [x] : type i PairOf (x : , y : [x]) : type i PairOf (x : , y : [x]) : type i u : w : [u] Pair(u, w) : PairOf (x : , y : [x]) 1(Pair(u, w)) . = u 2(Pair(u, w)) . = w p : PairOf (x : , y : [x]) 1(p) : 2(p) : [1(p)] p . = Pair(1(p), 2(p)) e . = e u . = w w . = u u . = w w . = s u . = s u . = w [u] [w] : type i ; x : [x] : Bool SubType (x : , [x]) : type i SubType (x : , [x]) : type i e : [e] e : SubType (x : , [x]) e : SubType (x : , [x]) e : [e] : type i ; x : [x] : type i (x : [x]) : type i (x : [x]) : type i w : e : [w] e : (x : [x]) e : (x : [x]) ; y : ; z : [y] [z] y does not occur free in [z] [e] Figure 3: Pair Types, Subtypes and Existential Types. Note the use of absolute equality (judgemental equality) . = in the rules for pair types. We can have two distinct but isomorphic things we can have a = b with a . = b. It is important that absolute equalities are not Boolean expressions otherwise the substitution of isomorphics would yield that a = b implies a . = b. abbreviate SubType z : PairOf (x : , y : [x]) , [ 1 (z), 2 (z)] . The type of groups, abbreviated Group, can then be written as PairOf ( : type, f : ( ) s. t. [, f ]) where [, f ] states the group axioms. For example, the group axiom that an identity element exists can be written as x : y : f (x, y) = y f (y, x) = y. The type of topological spaces, denoted TOP, can be written as PairOf : type, Open : ( Bool) Bool, s. t. [, Open] where [, Open] states the topology axioms. Here the open sets of the topological space are rep- resented by predicates. Note that the types Group and TOP are closed type expressions these type expressions do not contain free variables. We should note that subtypes are literally subsets and, for example, we can derive the sequent G : AbelianGroup G : Group. Existential types have the form x : [x] where [x] is a type expression. This is the type whose members are those values v such that there exists a value u : such that v is in the type [u]. Existen- tial types allow one to express the type of permuta- tion groups as distinct from the type of groups. A permutation group is a group whose group elements are permutations of an underlying set. The type of permutation groups, denoted PermGroup, has the 79 form : type P : (Permutation[] Bool) [, P ]. Here the predicate P represents a set of permu- tations on the type and [, P ] is a pair type specifying a group whose elements are the permu- tations of satisfying P and where the group op- eration is functional composition. Again note that PermGroup is a closed type expression. The rules for existential types then allow the derivation of the sequent G : PermGroup G : Group. We also have the representation theorem G : Group H : PermGroup G = Group H. However, the isomorphism relations = Group and = PermGroup are different. Two permutation groups can be group-isomorphic while operating on un- derlying sets of different sizes. Such permutation groups are group-isomorphic but not permutation- group-isomorphic. 3 Observational Equivalence Our intention now is to interpret an equation such as G = Group H as stating that G and H are group- isomorphic. The significance of isomorphism arises from the substitution rule of figure 2. The rules of equality reflexivity, symetry, transitivity and substitution support the congruence closure algo- rithm for reasoning about equality. The ability to ap- ply congruence closure to the isomorphism relation should be of great value in automated reasoning. 1 The core rules define a notion of observational equivalence two closed terms a and b of type are observationally -equivalent if for every predi- cate expression P : Bool (typable by the core rules) we have P (a) if and only if P (b). We want = to be as course as possible subject to the con- straint that a = b implies that a and b are observa- tionally -equivalent. The desire to be as coarse as possible while staying within observational equivalence motivates the interpretation of type-isomorphism as same- cardinality. Predicates on types that are well formed 1 It is tempting to suggest that congruence closure is of great value in subconscious human thought. under the core rules cannot distinguish between types of the same cardinality. 4 Morphoids The semantics of morphoid type theory is developed within a meta-theory of Platonic mathematics we adopt the position that it is meaningful to discuss actual (Platonic) mathematical objects. The semantics of morphoid type theory is based on a class of values called morphoids. A rigorous definition of a class of morphoids for a subset of the language can be found in (McAllester, 2014) version 4. Here we give some intuition for morphoids and state some formal properties. Morphoids are built from points. Morphoid points are analogous to the ur-elements of some early versions of set theory. General morphoids are built from points in a manner analogous to the way that sets are constructed from ur-elements. A morphoid point has the form Point(i, j) where i is called the left index and j is the right index of the point. We define the operations of Left, Right, inverse and composition on points as follows. Left(Point(i, j)) = Point(i, i) Right(Point(i, j)) = Point(j, j) Point(i, j) 1 = Point(j, i) Point(i, j) Point(j, k) = Point(i, k) Here we have that x y is defined only in the case where Right(x) = Left(y). Every morphoid value is either a Boolean value (True or False), a point, a morphoid type, a pair of morphoid values, or a morphoid function. The operations of Left, Right, inverse and composition are defined recursively on all morphoid values where x y is defined when Right(x) = Left(y). We consider each kind of value in turn. A morphoid type is a set of morphoid values satisfying certain properties defined in (McAllester, 2014). A fundamental property is the following. (M) For x, y, x with xy 1 z defined we have x y 1 z . The following equations define the morphoid op- erations on types where is defined only when 80 Left() Right() Point(a, A), Point(a, A), Point(  a, A), Point(  a, A), Point(b, B), Point(b, B), Point( b, B), Point( b, B), Point(c, C), Point(c, C), Point(  c, C), Point(  c, C) Point(a, a), Point(a, a), Point(  a, a), Point(  a, a), Point(b, b), Point(b, b), Point( b, b), Point( b, b), Point(c, c), Point(c, c), Point(  c, c), Point(  c, c) Point(A, A), Point(A, A), Point( A, A), Point( A, A), Point(B, B), Point(B, B), Point( B, B), Point( B, B), Point(C, C), Point(C, C), Point( C, C), Point( C, C) 1 Point(A, a), Point( A, a), Point( A, a), Point( A, a), Point(B, b), Point( B, b), Point( B, b), Point( B, b), Point(C, c), Point( C, c), Point( C, c), Point( C, c) Point(A, AA), Point(A, AA), Point( A, AA), Point( A, AA), Point(B, BB), Point(B, BB), Point( B, BB), Point( B, BB), Point(C, CC), Point(C, CC), Point( C, CC), Point( C, CC) Point(a, AA), Point(a, AA), Point(  a, AA), Point(  a, AA), Point(b, BB), Point(b, BB), Point( b, BB), Point( b, BB), Point(c, CC), Point(c, CC), Point(  c, CC), Point(  c, CC) Figure 4: The operations of Left, Right, inverse and composition on point types. G Left(G) Right(G) Point(a,A) Point(a,a) Point(A,A) \ \ \ Point(b,B) Point(b,b) Point(B,B) / / / Point(c,C) Point(c,c) Point(C,C) G 1 H G H Point(A,a) Point(A,AA) Point(a,AA) \ \ \ Point(B,b) Point(B,BB) Point(b,BB) / / / Point(C,c) Point(C,CC) Point(c,CC) Figure 5: The operations of Left, Right, inverse and composition on abstract morphoid graphs. 81 Right() = Left( ). Left() = x 1 x 1 2 : x 1 , x 2 , Right(x 1 ) = Right(x 2 ) Right() = x 1 1 x 2 : x 1 , x 2 , Left(x 1 ) = Left(x 2 ) = x y : x , y , Right(x) = Left(y) 1 = {x 1 : x } A morphoid type whose elements are points is called a point type. Figure 4 gives examples of mor- phoid point types and examples of the morphoid op- erations applied to point types. The morphoid clo- sure condition (M) implies that for any morphoid type we have that Left() and Right() are equivalence relations (see figure 4). Note that mor- phoid types are not required to be closed under in- verse. This allows types to be directed from left to right. Again consider the types in figure 4. Fur- thermore, property (M) implies that any morphoid type defines a bijection between the equivalence classes of Left() and the equivalence classes of Right(). A morphoid pair is simply a pair of morphoids. The morphoid operations on pairs are defined as follows where again x y is defined only when Right(x) = Left(y). Left(Pair(x, y)) = Pair(Left(x), Left(y)) Right(Pair(x, y)) = Pair(Right(x), Right(y)) Pair(x, y) 1 = Pair(x 1 , y 1 ) Pair(x, y) Pair(z, w) = Pair(x z, y w) The treatment of morphoid functions involves subtleties. In this synopsis we note only that for any two morphoid types and we can define the type such that for f and x we can define the application f (x) so that we have f (x) . Furthermore, these definitions are such that the elements of the type represents all functions from the equivalence classes of to the equivalence classes of . Details, including the defi- nitions of the morphoid operations on functions, can be found in (McAllester, 2014). It is possible to prove that morphoids satisfy the following properties where properties (G4), (G5), (G6), and (G9) apply when the compositions are de- fined. (G1) For any morphoid x we have that Left(x), Right(x) and x 1 are also morphoids. (G2) For any morphoids x and y we have that x y is defined if and only if Right(x) = Left(y) and when x y is defined we have that x y is a morphoid. (G3) Left(x 1 ) = Right(x) and Right(x 1 ) = Left(x) (G4) Left(x y) = Left(x) and Right(x y) = Right(y). (G5) (x y) z = x (y z). (G6) x 1 x y = y and x y y 1 = x. (G7) Right(x) = x 1 x and Left(x) = x x 1 . (G8) (x 1 ) 1 = x. (G9) (x y) 1 = y 1 x 1 . Properties (G1) through (G9) state that the class of morphoids forms a groupoid under the morphoid operations. Figure 5 shows morphoid operations on graphs whose nodes are points. 5 Abstraction and Isomorphism The semantic definition of isomorphism relies on an additional operation on morphoids the operation of abstraction. As an example we consider vector spaces. In morphoid type theory an abstract vector space is one in which the vectors are points. The space R n is a vector space whose vectors are n- tuples of real numbers. A tuple of real numbers is an implementation of a vector a tuple of real num- bers is not a point. However, we can define an ab- straction operation such that for any morphoid value x we have that x@Point is a point. Details can be found in (McAllester, 2014). There is an abstraction ordering on morphoids where x y if x can be converted to y by ab- stracting parts of x to points. For every type there is a set of maximally abstract elements of that type. The maximally abstract graphs are the graphs whose nodes are points. The maximally abstract vector 82 spaces are those vector spaces in which the vectors are points. The maximally abstract types are the point types. For each morphoid type it is possible to define an abstraction operation mapping x to x@ where x@ is a maximally abstract member of . For example, for any morphoid type type i we have that @type i is the point type whose mem- bers are the points of the form x@Point for x . Details can be found in (McAllester, 2014). The isomorphism relation x = y is defined to mean that x , y , and there exists z such that (x@) z 1 (y@) is defined. Condi- tion (M) on morphoid types guarantees that this is an equivalence relation on the elements of . </chunk></section><section><heading>6 The Semantic Value Function </heading><chunk>The semantics of morphoid type theory is an exten- sion of the sementics of predicate calculus. The semantics involves three concepts variable in- terpretations, semantic entailment, and a semantic value function. These three concepts are defined by mutual recursion where the recursion reduces the size of the expressions involved. A variable inter- pretation assigns a value to each variable declared in a given context. More formally, for any well- formed context we write V for the set of vari- able interpretations consistent with declarations and Boolean assertions in . We define V by the following rules where this is undefined if no rule ap- plies. We define V to be the set containing the empty variable interpretation. V ; x : is defined if V is defined, x is not declared in , and |= : type i in which case V ; x : is defined to be the set of vari- able interpretations of the form [x v] for V and v V . V ; is defined if V is defined and |= : Bool in which case V ; is defined to be the set of all V such that V = True. A semantic entailment is written as |= and this holds if V is defined and holds under all variable interpretations in V . The entailment re- lation |= holds if one of the following clauses applies. The entailment |= e : holds if V , V e and V are all defined and for all V we have that V is a morphoid type and V e V . For a Boolean expression , i.e., for |= : Bool, we have that |= holds if for all V we have V = True. We write |= e 1 . = e 2 if V , V e 1 and V e 2 are all defined and for V we have that V e 1 and V e 2 are the same value. For V defined and for an expression e that is well-formed in the context , we have a semantic value function V e. The semantic value function V e maps a variable interpretation V to a morphoid value V e . For V defined, the following clauses state when V e is defined and, when it is defined, define the value V e for V . x. For x declared in and for V we have that V x is defined with V x = (x). Bool. We have that V Bool is the type con- taining the two Boolean values True and False. type i . We have V type i is the type whose members are all morphoid types in the set-theoretic universe V i where i is the ith inaccessible cardi- nal. . If |= : type i , and |= : type i , then V is defined with V = (V ) (V ). f (e). If V f and V e are defined and for all V we have that V f can be ap- plied to V e then V f (e) is defined with V f (e) = (V f )(V e ). x : [x]. If ; y : |= [y] : Bool then V x : [x] is defined with V x : [x] being True if for all v V we have V ;y : [y] [y v] = True. . If |= : Bool and |= : Bool then V is defined with V = V V . . If |= : Bool then V is defined with V = V . 83 Bijection[, ] SubType(f : , y : !x : f (x) = y) a ; b z : iso(, a, b) : type i a : b : iso(, a, b) : type i , : type i f : Bijection[, ] (, , f ) : iso(type i , , ) x : x ; (,,f ) f (x) : iso(type i , , ) : Bijection[, ] : Bijection[, ] x : y : (x ; y) z : (z) = x (z) = y c : iso(, a, b) c : a : , b : c : iso(, a, b) a = c b = c a = b a ; b ; x : ; y : [x] e[x, y] : [x, y] a 1 : , a 2 : , a 3 : iso(, a 1 , a 2 ) b 1 : [a 1 ], b 2 : [a 2 ], b 3 : iso([a 3 ], b 1 , b 2 ) e[a 3 , b 3 ] : iso( [a 3 , b 3 ], e[a 1 , b 1 ], e[a 2 , b 2 ]) 3 : iso(type i , 1 , 2 ) f 1 : 1 1 , f 2 : 2 2 , f 3 : 3 3 ; z : 3 f 3 (z) : iso( 3 , f 1 ( 31 (z)), f 2 ( 32 (z))) f 3 : iso( 3 3 , f 1 , f 2 ) c : iso(, a, b) [c] c : iso(SubType(x : , [x]), a, b) c : iso( [d], a, b) d : c : iso(x : [x], a, b) Figure 6: Internalizing Isomorphism. Here iso(, x, y) is the type whose elements are the -isomorphisms from x to y. The fourth row gives the rules of iso-substition and iso-extensionality. s = w. If |= s : and |= w : then V s = w is defined with V s = w being True if V s = V V w . The(x : , [x]). If |= !y : [y] then V The(x : , [x]) = The(V SubType(x : , [x]) ). PairOf (x : , y : [x]) . If |= : type i and ; z : |= [z] : type i then V PairOf (x : , y : [x]) is defined with V PairOf (x : , y : [x]) being the type con- taining the pairs Pair(v, w) for v V and w V ; z : [z] [z v]. Pair(u, w). If V u and V w are de- fined then V Pair(u, w) is defined with V Pair(u, w) = Pair(V u , V w ). i (e). If V e is defined and for all V we have that V e is a pair then V i (e) is defined with V i (e) = i (V e ). SubType (x : , [x]) . If |= : type i and ; y : |= [y] : Bool then </chunk></section><section><heading>V SubType(x : , [x]) is defined with </heading><chunk>V SubType (x : , [x]) being the type whose members are those values v V with V ; y : [y] [y v] = True. x : [x]. If ; y : |= [y] : type i then V x : [x] is defined with V x : [x] being the type containing those values w such that there exists u V with w V [y] [y u]. The morphoid operations can also be defined on variable interpretations. For V we have 84 ; : type i [] : type i : type i , : type i , f : Bijection[, ] a : [], b : [ ], a ; [(,,f )] b Pair(, a) = PairOf ( : type i , y : []) Pair(, b) ; : type i [], [] : type i , : type i f : Bijection[, ] a : PairOf ([], []) b : PairOf ([ ], [ ]) (a ; PairOf ([(,,f )], [(,,f )]) b) 1 (a) ; [(,,f )] 1 (b) 2 (a) ; [(,,f )] 2 (b) ; : type i [], [] : type i , : type i f : Bijection[, ] g : [] [] h : [ ] [ ] (g ; [(,,f )][(,,f )] h) x 1 : [] x 2 : [ ] (x 1 ; [(,,f )] x 2 ) g(x 1 ) ; [(,,f )] h(x 2 ) Figure 7: Some Derived Rules. The rules in this figure can be derived from the rules in figure 6. The first rule constructs isomorphism relations at types of the form PairOf ( : type i , y : []). The rule states that Pair(, a) is isomorphic to Pair(, b) if there exists a bijection f from to that carries a to b. The rules in the second row allow one to determine whether f carries a to b in the case where [] is a simple type over (see the text). There are two base cases not listed in the figure. For [] = we have that a ; (,,f ) b if and only if f (a) = b. If [] does not depend on we have a ; b if and only if a = b. that Left() is the variable interpretation that maps x to Left((x)). Right() is defined similarly. For V we have that 1 maps x to (x) 1 . For , V we have that is defined if and only if Right() = Left() in which case is the variable interpretation mapping x to (x) (x). A fundamental property of Morphoid type theory is that if V is defined then it is closed under in- verse and composition for V we have 1 V and for , V with defined we have ( ) V . Furthermore for V e defined and for , V we have V e ( ) = (V e ) (V e ) and V e ( 1 ) = (V e ) 1 . Another fundamental property of the value func- tion involves the abstraction ordering. The abstrac- tion ordering can be extended to variable interpreta- tions where we have if and are defined on the same set of variables and for each variable x we have (x) (x). The value function is monotone with respect to the abstraction ordering for we have V e V e . </chunk></section><section><heading>7 Internalizing Isomorphism </heading><chunk>Figure 6 gives inference rules for isomorphism. Fig- ure 7 gives rules which can be derived from the rules in figure 6. The first rule in figure 7 de- rives isomorphisms at types of the form PairOf( : type i , []). We note that types Group and TOP as defined in section 2 can be written as sub- types of pair types of this form. The rule states that two objects Pair(, a) and Pair(, b) of type PairOf( : type i , []) are isomorphic if there exists a bijection f from to which carries a to b. The two rules in the second row of figure 7 al- low one to determine whether or not f carries a to b in the case where [] is a simple type over 85 . To define the simple types we first introduce the notation PairOf (, ) as an abbreviation for PairOf (x : , y : ) in the case where x does not occur in . A simple type expression [] over the type variable is then defined to be either the vari- able itself, a type not containing , or a type of the form PairOf ([], []) or [] [] where [] and [] are recursively simple type ex- pressions over . Subtypes of pair types of the form PairOf ( : type i , []) where [] is a simple type over covers the types Group and TOP as well as many other mathematical concepts. We leave the derivation of the rules in the second row of fig- ure 7 as a (tricky and tedious) exercise for the reader. While the rules in figure 7 are adequate in many situations, they do not cover types such as Pairof (p : Pairof (type i , type i ), y : [p]) or Pairof (G : Group, H : [G]) or Pairof (f : type i type i , A : [f ]). For the general case we need the rules of figure 6. 8 Summary Morphoid type theory is a type-theoretic foundation for mathematics supporting the concept of isomor- phism and the substitution of isomorphics. Mor- phoid type theory is an extension of classical predi- cate calculus that avoids the use of propositions-as- types, path induction or squashing. Morphoid type theory may be more comfortable for mathemticians who take a realist or Platonic approach to the prac- tice of mathematics. </chunk></section><section><heading>References </heading><chunk>Thierry Coquand and Gerard Huet. 1988. The calcu- lus of constructions. Information and computation, 76(2):95120. Martin Hofmann and Thomas Streicher. 1994. The groupoid model refutes uniqueness of identity proofs. In Logic in Computer Science, 1994. LICS94. Pro- ceedings., Symposium on, pages 208212. IEEE. HoTT-Authors. 2013. Homotopy type the- ory, univalent foundations of mathematics. http://hottheory.files.wordpress.com/2013/03/hott- online-611-ga1a258c.pdf. Per Martin-L  of. 1971. A theory of types. David McAllester. 2014. Morphoid type theory. CoRR, abs/1407.7274. John C. Reynolds. 1983. Types, abstraction and para- metric polymorphism. In IFIP Congress, pages 513 523. Giovanni Sambin and Jan M Smith. 1998. Twenty Five Years of Constructive Type Theory, volume 36. Oxford University Press. 86 </chunk></section></sec_map>